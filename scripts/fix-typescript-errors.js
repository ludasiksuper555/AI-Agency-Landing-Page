#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

console.log('üîß –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ TypeScript –æ—à–∏–±–æ–∫...');

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞
function readFile(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch (error) {
    console.error(`‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ ${filePath}:`, error.message);
    return null;
  }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø–∏—Å–∏ —Ñ–∞–π–ª–∞
function writeFile(filePath, content) {
  try {
    fs.writeFileSync(filePath, content, 'utf8');
    console.log(`‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω —Ñ–∞–π–ª: ${filePath}`);
    return true;
  } catch (error) {
    console.error(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ —Ñ–∞–π–ª–∞ ${filePath}:`, error.message);
    return false;
  }
}

// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ authStore.ts
function fixAuthStore() {
  const filePath = path.join(process.cwd(), 'store', 'authStore.ts');
  let content = readFile(filePath);

  if (!content) return false;

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∏–º–ø–æ—Ä—Ç–æ–≤
  const hasCreateImport = content.includes('import { create }');
  const hasPersistImport = content.includes('import { persist }');

  if (!hasCreateImport || !hasPersistImport) {
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∏–º–ø–æ—Ä—Ç—ã –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞
    const imports = [];
    if (!hasCreateImport) {
      imports.push("import { create } from 'zustand';");
    }
    if (!hasPersistImport) {
      imports.push("import { persist } from 'zustand/middleware';");
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É —Å import –∏ –≤—Å—Ç–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–¥ –Ω–µ–π
    const lines = content.split('\n');
    const firstImportIndex = lines.findIndex(line => line.trim().startsWith('import'));

    if (firstImportIndex !== -1) {
      lines.splice(firstImportIndex, 0, ...imports);
      content = lines.join('\n');
    } else {
      // –ï—Å–ª–∏ –Ω–µ—Ç –∏–º–ø–æ—Ä—Ç–æ–≤, –¥–æ–±–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ
      content = imports.join('\n') + '\n\n' + content;
    }

    return writeFile(filePath, content);
  }

  console.log(`‚úÖ authStore.ts —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∏–º–ø–æ—Ä—Ç—ã`);
  return true;
}

// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ meatIndustryAnalytics.ts
function fixMeatIndustryAnalytics() {
  const filePath = path.join(process.cwd(), 'utils', 'meatIndustryAnalytics.ts');
  let content = readFile(filePath);

  if (!content) return false;

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ ProductAnalytics
  if (!content.includes('interface ProductAnalytics')) {
    const interfaceDefinition = `
// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –º—è—Å–Ω–æ–π –ø—Ä–æ–º—ã—à–ª–µ–Ω–Ω–æ—Å—Ç–∏
interface ProductAnalytics {
  id: string;
  name: string;
  price: number;
  category: string;
  supplier: string;
  quantity: number;
  unit: string;
  lastUpdated: Date;
  trends: {
    daily: number;
    weekly: number;
    monthly: number;
  };
}

interface MarketData {
  region: string;
  products: ProductAnalytics[];
  marketTrends: {
    priceIndex: number;
    demandLevel: 'low' | 'medium' | 'high';
    seasonalFactor: number;
  };
}

interface AnalyticsResponse {
  success: boolean;
  data: MarketData[];
  timestamp: string;
  error?: string;
}
`;

    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –ø–æ—Å–ª–µ –∏–º–ø–æ—Ä—Ç–æ–≤
    const lines = content.split('\n');
    const lastImportIndex = lines.findLastIndex(line => line.trim().startsWith('import'));

    if (lastImportIndex !== -1) {
      lines.splice(lastImportIndex + 1, 0, interfaceDefinition);
    } else {
      lines.unshift(interfaceDefinition);
    }

    content = lines.join('\n');
    return writeFile(filePath, content);
  }

  console.log(`‚úÖ meatIndustryAnalytics.ts —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã`);
  return true;
}

// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ mgxUtils.ts
function fixMgxUtils() {
  const filePath = path.join(process.cwd(), 'utils', 'mgxUtils.ts');
  let content = readFile(filePath);

  if (!content) return false;

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ MGXAuthResponse
  if (!content.includes('interface MGXAuthResponse')) {
    const interfaceDefinition = `
// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è MGX API
interface User {
  id: string;
  email: string;
  name: string;
  role: string;
  permissions: string[];
}

interface MGXAuthResponse {
  success: boolean;
  token: string;
  refreshToken: string;
  user: User;
  expiresIn: number;
  error?: string;
}

interface MGXApiResponse<T = any> {
  success: boolean;
  data: T;
  message: string;
  timestamp: string;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

interface MGXConfig {
  baseUrl: string;
  apiKey: string;
  timeout: number;
  retryAttempts: number;
}
`;

    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –ø–æ—Å–ª–µ –∏–º–ø–æ—Ä—Ç–æ–≤
    const lines = content.split('\n');
    const lastImportIndex = lines.findLastIndex(line => line.trim().startsWith('import'));

    if (lastImportIndex !== -1) {
      lines.splice(lastImportIndex + 1, 0, interfaceDefinition);
    } else {
      lines.unshift(interfaceDefinition);
    }

    content = lines.join('\n');
    return writeFile(filePath, content);
  }

  console.log(`‚úÖ mgxUtils.ts —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã`);
  return true;
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ TypeScript –æ—à–∏–±–æ–∫
function checkTypeScriptErrors() {
  try {
    console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ TypeScript –æ—à–∏–±–æ–∫...');
    execSync('npx tsc --noEmit', { stdio: 'pipe' });
    console.log('‚úÖ TypeScript –æ—à–∏–±–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!');
    return true;
  } catch (error) {
    const output = error.stdout ? error.stdout.toString() : error.message;
    console.log('‚ùå –ù–∞–π–¥–µ–Ω—ã TypeScript –æ—à–∏–±–∫–∏:');
    console.log(output);
    return false;
  }
}

// –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
async function main() {
  console.log('üöÄ –ù–∞—á–∏–Ω–∞–µ–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ TypeScript –æ—à–∏–±–æ–∫...\n');

  const fixes = [
    { name: 'authStore.ts', fix: fixAuthStore },
    { name: 'meatIndustryAnalytics.ts', fix: fixMeatIndustryAnalytics },
    { name: 'mgxUtils.ts', fix: fixMgxUtils },
  ];

  let successCount = 0;

  for (const { name, fix } of fixes) {
    console.log(`üîß –ò—Å–ø—Ä–∞–≤–ª—è–µ–º ${name}...`);
    if (fix()) {
      successCount++;
    }
    console.log('');
  }

  console.log(`üìä –†–µ–∑—É–ª—å—Ç–∞—Ç: ${successCount}/${fixes.length} —Ñ–∞–π–ª–æ–≤ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ\n`);

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  if (checkTypeScriptErrors()) {
    console.log('üéâ –í—Å–µ TypeScript –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã!');

    // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –∫–∞—á–µ—Å—Ç–≤–∞
    try {
      console.log('\nüîç –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–¥–∞...');
      execSync('npm run type-check', { stdio: 'inherit' });
      console.log('‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!');
    } catch (error) {
      console.log('‚ö†Ô∏è –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –≤—ã—è–≤–∏–ª–∞ –ø—Ä–æ–±–ª–µ–º—ã');
    }
  } else {
    console.log('‚ö†Ô∏è –û—Å—Ç–∞–ª–∏—Å—å –Ω–µ—Ä–µ—à–µ–Ω–Ω—ã–µ TypeScript –æ—à–∏–±–∫–∏');
    console.log('üí° –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —Ä—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤');
  }
}

// –ó–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞
if (require.main === module) {
  main().catch(error => {
    console.error('‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–∫—Ä–∏–ø—Ç–∞:', error.message);
    process.exit(1);
  });
}

module.exports = {
  fixAuthStore,
  fixMeatIndustryAnalytics,
  fixMgxUtils,
  checkTypeScriptErrors,
};
