# –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

## –û–±–∑–æ—Ä

–≠—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –æ–ø–∏—Å—ã–≤–∞–µ—Ç –ø–æ–ª–∏—Ç–∏–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏, –ª—É—á—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏ –∏ –ø—Ä–æ—Ü–µ–¥—É—Ä—ã –¥–ª—è AI Agency Landing Page.

## üîí –ü–æ–ª–∏—Ç–∏–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

### –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –≤–µ—Ä—Å–∏–∏

| –í–µ—Ä—Å–∏—è | –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏           |
| ------ | -------------------------------- |
| 2.x.x  | ‚úÖ –ü–æ–ª–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞              |
| 1.x.x  | ‚ö†Ô∏è –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ |
| < 1.0  | ‚ùå –ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è             |

### –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—è–∑–≤–∏–º–æ—Å—Ç—è—Ö

–ï—Å–ª–∏ –≤—ã –æ–±–Ω–∞—Ä—É–∂–∏–ª–∏ —É—è–∑–≤–∏–º–æ—Å—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞:

1. **–ù–ï —Å–æ–∑–¥–∞–≤–∞–π—Ç–µ –ø—É–±–ª–∏—á–Ω—ã–π issue**
2. –û—Ç–ø—Ä–∞–≤—å—Ç–µ email –Ω–∞: security@ai-agency.com
3. –í–∫–ª—é—á–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —É—è–∑–≤–∏–º–æ—Å—Ç–∏
4. –ü—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ —à–∞–≥–∏ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
5. –£–∫–∞–∂–∏—Ç–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ

**–í—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞**: 24 —á–∞—Å–∞
**–í—Ä–µ–º—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è**: 72 —á–∞—Å–∞ –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π

## üõ°Ô∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

### –ü—Ä–∏–Ω—Ü–∏–ø—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

1. **Defense in Depth** - –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è –∑–∞—â–∏—Ç–∞
2. **Principle of Least Privilege** - –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø—Ä–∞–≤–∞
3. **Zero Trust** - –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
4. **Security by Design** - –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —Å —Å–∞–º–æ–≥–æ –Ω–∞—á–∞–ª–∞
5. **Fail Secure** - –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –æ—Ç–∫–∞–∑ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö

### –ú–æ–¥–µ–ª—å —É–≥—Ä–æ–∑

```mermaid
graph TD
    A[–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å] --> B[CDN/WAF]
    B --> C[Load Balancer]
    C --> D[Next.js App]
    D --> E[API Routes]
    E --> F[Database]

    G[–ê—Ç–∞–∫—É—é—â–∏–π] -.-> B
    G -.-> D
    G -.-> E
    G -.-> F

    H[–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥] --> D
    H --> E
    H --> F
```

## üîê –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è

### JWT —Ç–æ–∫–µ–Ω—ã

```typescript
// lib/auth/jwt.ts
import jwt from 'jsonwebtoken';
import { NextApiRequest } from 'next';

interface JWTPayload {
  userId: string;
  email: string;
  role: string;
  iat: number;
  exp: number;
}

export class JWTService {
  private readonly secret: string;
  private readonly issuer: string;
  private readonly audience: string;

  constructor() {
    this.secret = process.env.JWT_SECRET!;
    this.issuer = process.env.JWT_ISSUER || 'ai-agency';
    this.audience = process.env.JWT_AUDIENCE || 'ai-agency-users';

    if (!this.secret) {
      throw new Error('JWT_SECRET environment variable is required');
    }
  }

  generateToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    return jwt.sign(payload, this.secret, {
      expiresIn: '1h',
      issuer: this.issuer,
      audience: this.audience,
      algorithm: 'HS256',
    });
  }

  generateRefreshToken(userId: string): string {
    return jwt.sign({ userId, type: 'refresh' }, this.secret, {
      expiresIn: '7d',
      issuer: this.issuer,
      audience: this.audience,
      algorithm: 'HS256',
    });
  }

  verifyToken(token: string): JWTPayload {
    try {
      return jwt.verify(token, this.secret, {
        issuer: this.issuer,
        audience: this.audience,
        algorithms: ['HS256'],
      }) as JWTPayload;
    } catch (error) {
      throw new Error('Invalid token');
    }
  }

  extractTokenFromRequest(req: NextApiRequest): string | null {
    const authHeader = req.headers.authorization;

    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }

    return null;
  }
}

export const jwtService = new JWTService();
```

### Middleware –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏

```typescript
// middleware/auth.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { jwtService } from '../lib/auth/jwt';
import { rateLimiter } from '../lib/security/rate-limiter';

export interface AuthenticatedRequest extends NextApiRequest {
  user: {
    userId: string;
    email: string;
    role: string;
  };
}

export function withAuth(
  handler: (req: AuthenticatedRequest, res: NextApiResponse) => Promise<void>
) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    try {
      // Rate limiting
      const clientIp = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
      const isAllowed = await rateLimiter.checkLimit(clientIp as string);

      if (!isAllowed) {
        return res.status(429).json({ error: 'Too many requests' });
      }

      // Token extraction and verification
      const token = jwtService.extractTokenFromRequest(req);

      if (!token) {
        return res.status(401).json({ error: 'Authentication required' });
      }

      const payload = jwtService.verifyToken(token);

      // Attach user to request
      (req as AuthenticatedRequest).user = {
        userId: payload.userId,
        email: payload.email,
        role: payload.role,
      };

      return handler(req as AuthenticatedRequest, res);
    } catch (error) {
      console.error('Authentication error:', error);
      return res.status(401).json({ error: 'Invalid authentication' });
    }
  };
}

// Role-based access control
export function withRole(roles: string[]) {
  return function (handler: (req: AuthenticatedRequest, res: NextApiResponse) => Promise<void>) {
    return withAuth(async (req: AuthenticatedRequest, res: NextApiResponse) => {
      if (!roles.includes(req.user.role)) {
        return res.status(403).json({ error: 'Insufficient permissions' });
      }

      return handler(req, res);
    });
  };
}
```

## üö´ –ó–∞—â–∏—Ç–∞ –æ—Ç –∞—Ç–∞–∫

### CSRF Protection

```typescript
// lib/security/csrf.ts
import crypto from 'crypto';
import { NextApiRequest, NextApiResponse } from 'next';

export class CSRFProtection {
  private readonly secret: string;

  constructor() {
    this.secret = process.env.CSRF_SECRET || crypto.randomBytes(32).toString('hex');
  }

  generateToken(sessionId: string): string {
    const timestamp = Date.now().toString();
    const data = `${sessionId}:${timestamp}`;
    const hash = crypto.createHmac('sha256', this.secret).update(data).digest('hex');

    return Buffer.from(`${data}:${hash}`).toString('base64');
  }

  verifyToken(token: string, sessionId: string): boolean {
    try {
      const decoded = Buffer.from(token, 'base64').toString('utf8');
      const [receivedSessionId, timestamp, hash] = decoded.split(':');

      // Check session ID
      if (receivedSessionId !== sessionId) {
        return false;
      }

      // Check timestamp (token valid for 1 hour)
      const tokenAge = Date.now() - parseInt(timestamp);
      if (tokenAge > 3600000) {
        return false;
      }

      // Verify hash
      const data = `${receivedSessionId}:${timestamp}`;
      const expectedHash = crypto.createHmac('sha256', this.secret).update(data).digest('hex');

      return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(expectedHash));
    } catch (error) {
      return false;
    }
  }
}

export const csrfProtection = new CSRFProtection();

export function withCSRF(handler: (req: NextApiRequest, res: NextApiResponse) => Promise<void>) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    if (req.method === 'GET' || req.method === 'HEAD' || req.method === 'OPTIONS') {
      return handler(req, res);
    }

    const token = req.headers['x-csrf-token'] as string;
    const sessionId = req.headers['x-session-id'] as string;

    if (!token || !sessionId || !csrfProtection.verifyToken(token, sessionId)) {
      return res.status(403).json({ error: 'Invalid CSRF token' });
    }

    return handler(req, res);
  };
}
```

### Rate Limiting

```typescript
// lib/security/rate-limiter.ts
import Redis from 'ioredis';

interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
}

export class RateLimiter {
  private redis: Redis;
  private config: RateLimitConfig;

  constructor(config: RateLimitConfig) {
    this.config = config;
    this.redis = new Redis(process.env.REDIS_URL!);
  }

  async checkLimit(identifier: string): Promise<boolean> {
    const key = `rate_limit:${identifier}`;
    const window = Math.floor(Date.now() / this.config.windowMs);
    const windowKey = `${key}:${window}`;

    const current = await this.redis.incr(windowKey);

    if (current === 1) {
      await this.redis.expire(windowKey, Math.ceil(this.config.windowMs / 1000));
    }

    return current <= this.config.maxRequests;
  }

  async getRemainingRequests(identifier: string): Promise<number> {
    const key = `rate_limit:${identifier}`;
    const window = Math.floor(Date.now() / this.config.windowMs);
    const windowKey = `${key}:${window}`;

    const current = await this.redis.get(windowKey);
    const used = current ? parseInt(current) : 0;

    return Math.max(0, this.config.maxRequests - used);
  }

  async resetLimit(identifier: string): Promise<void> {
    const key = `rate_limit:${identifier}`;
    const window = Math.floor(Date.now() / this.config.windowMs);
    const windowKey = `${key}:${window}`;

    await this.redis.del(windowKey);
  }
}

// –†–∞–∑–ª–∏—á–Ω—ã–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
export const rateLimiters = {
  api: new RateLimiter({
    windowMs: 15 * 60 * 1000, // 15 –º–∏–Ω—É—Ç
    maxRequests: 100,
  }),

  auth: new RateLimiter({
    windowMs: 15 * 60 * 1000, // 15 –º–∏–Ω—É—Ç
    maxRequests: 5, // –°—Ç—Ä–æ–∂–µ –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
  }),

  contact: new RateLimiter({
    windowMs: 60 * 60 * 1000, // 1 —á–∞—Å
    maxRequests: 3, // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª—è –∫–æ–Ω—Ç–∞–∫—Ç–Ω–æ–π —Ñ–æ—Ä–º—ã
  }),
};
```

### XSS Protection

```typescript
// lib/security/xss-protection.ts
import DOMPurify from 'isomorphic-dompurify';
import { escape } from 'html-escaper';

export class XSSProtection {
  // –û—á–∏—Å—Ç–∫–∞ HTML –∫–æ–Ω—Ç–µ–Ω—Ç–∞
  static sanitizeHTML(dirty: string): string {
    return DOMPurify.sanitize(dirty, {
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
      ALLOWED_ATTR: ['href'],
      ALLOW_DATA_ATTR: false,
    });
  }

  // –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ HTML —Å—É—â–Ω–æ—Å—Ç–µ–π
  static escapeHTML(text: string): string {
    return escape(text);
  }

  // –í–∞–ª–∏–¥–∞—Ü–∏—è –∏ –æ—á–∏—Å—Ç–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –≤–≤–æ–¥–∞
  static sanitizeInput(input: any): any {
    if (typeof input === 'string') {
      return this.escapeHTML(input.trim());
    }

    if (Array.isArray(input)) {
      return input.map(item => this.sanitizeInput(item));
    }

    if (typeof input === 'object' && input !== null) {
      const sanitized: any = {};
      for (const [key, value] of Object.entries(input)) {
        sanitized[this.escapeHTML(key)] = this.sanitizeInput(value);
      }
      return sanitized;
    }

    return input;
  }

  // Content Security Policy
  static getCSPHeader(): string {
    const directives = [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.google-analytics.com https://www.googletagmanager.com",
      "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
      "font-src 'self' https://fonts.gstatic.com",
      "img-src 'self' data: https: blob:",
      "connect-src 'self' https://api.ai-agency.com https://www.google-analytics.com",
      "frame-src 'none'",
      "object-src 'none'",
      "base-uri 'self'",
      "form-action 'self'",
      "frame-ancestors 'none'",
      'upgrade-insecure-requests',
    ];

    return directives.join('; ');
  }
}

// Middleware –¥–ª—è XSS –∑–∞—â–∏—Ç—ã
export function withXSSProtection(
  handler: (req: NextApiRequest, res: NextApiResponse) => Promise<void>
) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ CSP –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
    res.setHeader('Content-Security-Policy', XSSProtection.getCSPHeader());
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');

    // –û—á–∏—Å—Ç–∫–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    if (req.body) {
      req.body = XSSProtection.sanitizeInput(req.body);
    }

    if (req.query) {
      req.query = XSSProtection.sanitizeInput(req.query);
    }

    return handler(req, res);
  };
}
```

### SQL Injection Protection

```typescript
// lib/security/sql-protection.ts
import { Pool } from 'pg';

export class DatabaseSecurity {
  private pool: Pool;

  constructor() {
    this.pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });
  }

  // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
  async query(text: string, params?: any[]): Promise<any> {
    const start = Date.now();

    try {
      // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ development
      if (process.env.NODE_ENV === 'development') {
        console.log('Executing query:', { text, params });
      }

      const result = await this.pool.query(text, params);
      const duration = Date.now() - start;

      // –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –º–µ–¥–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
      if (duration > 1000) {
        console.warn(`Slow query detected (${duration}ms):`, text);
      }

      return result;
    } catch (error) {
      console.error('Database query error:', error);
      throw error;
    }
  }

  // –í–∞–ª–∏–¥–∞—Ü–∏—è –∏ —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤
  escapeIdentifier(identifier: string): string {
    return '"' + identifier.replace(/"/g, '""') + '"';
  }

  // –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö WHERE —É—Å–ª–æ–≤–∏–π
  buildWhereClause(conditions: Record<string, any>): { text: string; params: any[] } {
    const clauses: string[] = [];
    const params: any[] = [];
    let paramIndex = 1;

    for (const [key, value] of Object.entries(conditions)) {
      // –í–∞–ª–∏–¥–∞—Ü–∏—è –∏–º–µ–Ω–∏ –∫–æ–ª–æ–Ω–∫–∏
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
        throw new Error(`Invalid column name: ${key}`);
      }

      if (Array.isArray(value)) {
        const placeholders = value.map(() => `$${paramIndex++}`).join(', ');
        clauses.push(`${this.escapeIdentifier(key)} IN (${placeholders})`);
        params.push(...value);
      } else {
        clauses.push(`${this.escapeIdentifier(key)} = $${paramIndex++}`);
        params.push(value);
      }
    }

    return {
      text: clauses.length > 0 ? `WHERE ${clauses.join(' AND ')}` : '',
      params,
    };
  }

  // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–ø–∏—Å–µ–π
  async findMany(
    table: string,
    conditions: Record<string, any> = {},
    options: {
      limit?: number;
      offset?: number;
      orderBy?: string;
      orderDirection?: 'ASC' | 'DESC';
    } = {}
  ): Promise<any[]> {
    // –í–∞–ª–∏–¥–∞—Ü–∏—è –∏–º–µ–Ω–∏ —Ç–∞–±–ª–∏—Ü—ã
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(table)) {
      throw new Error(`Invalid table name: ${table}`);
    }

    const { text: whereClause, params } = this.buildWhereClause(conditions);
    let paramIndex = params.length + 1;

    let query = `SELECT * FROM ${this.escapeIdentifier(table)} ${whereClause}`;

    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
    if (options.orderBy) {
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(options.orderBy)) {
        throw new Error(`Invalid order by column: ${options.orderBy}`);
      }
      const direction = options.orderDirection === 'DESC' ? 'DESC' : 'ASC';
      query += ` ORDER BY ${this.escapeIdentifier(options.orderBy)} ${direction}`;
    }

    // –õ–∏–º–∏—Ç
    if (options.limit) {
      query += ` LIMIT $${paramIndex++}`;
      params.push(options.limit);
    }

    // –°–º–µ—â–µ–Ω–∏–µ
    if (options.offset) {
      query += ` OFFSET $${paramIndex++}`;
      params.push(options.offset);
    }

    const result = await this.query(query, params);
    return result.rows;
  }

  async close(): Promise<void> {
    await this.pool.end();
  }
}

export const db = new DatabaseSecurity();
```

## üîç –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

### Security Event Logging

```typescript
// lib/security/security-logger.ts
import winston from 'winston';

interface SecurityEvent {
  type:
    | 'auth_failure'
    | 'rate_limit_exceeded'
    | 'suspicious_activity'
    | 'data_breach'
    | 'privilege_escalation';
  severity: 'low' | 'medium' | 'high' | 'critical';
  userId?: string;
  ip: string;
  userAgent: string;
  details: Record<string, any>;
  timestamp: Date;
}

export class SecurityLogger {
  private logger: winston.Logger;

  constructor() {
    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      defaultMeta: { service: 'ai-agency-security' },
      transports: [
        new winston.transports.File({ filename: 'logs/security-error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/security-combined.log' }),
      ],
    });

    if (process.env.NODE_ENV !== 'production') {
      this.logger.add(
        new winston.transports.Console({
          format: winston.format.simple(),
        })
      );
    }
  }

  logSecurityEvent(event: SecurityEvent): void {
    this.logger.log({
      level: this.mapSeverityToLevel(event.severity),
      message: `Security Event: ${event.type}`,
      ...event,
    });

    // –û—Ç–ø—Ä–∞–≤–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–æ–±—ã—Ç–∏–π –≤ —Å–∏—Å—Ç–µ–º—É –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    if (event.severity === 'critical') {
      this.sendAlert(event);
    }
  }

  private mapSeverityToLevel(severity: string): string {
    switch (severity) {
      case 'low':
        return 'info';
      case 'medium':
        return 'warn';
      case 'high':
        return 'error';
      case 'critical':
        return 'error';
      default:
        return 'info';
    }
  }

  private async sendAlert(event: SecurityEvent): Promise<void> {
    try {
      // –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Slack
      if (process.env.SLACK_SECURITY_WEBHOOK) {
        await fetch(process.env.SLACK_SECURITY_WEBHOOK, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: `üö® Critical Security Event: ${event.type}`,
            attachments: [
              {
                color: 'danger',
                fields: [
                  { title: 'Type', value: event.type, short: true },
                  { title: 'Severity', value: event.severity, short: true },
                  { title: 'IP', value: event.ip, short: true },
                  { title: 'User ID', value: event.userId || 'Unknown', short: true },
                  { title: 'Details', value: JSON.stringify(event.details), short: false },
                ],
                timestamp: event.timestamp.toISOString(),
              },
            ],
          }),
        });
      }

      // –û—Ç–ø—Ä–∞–≤–∫–∞ email –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º
      if (process.env.ADMIN_EMAIL) {
        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ email
      }
    } catch (error) {
      console.error('Failed to send security alert:', error);
    }
  }
}

export const securityLogger = new SecurityLogger();

// Middleware –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
export function withSecurityLogging(
  handler: (req: NextApiRequest, res: NextApiResponse) => Promise<void>
) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    const startTime = Date.now();
    const ip = (req.headers['x-forwarded-for'] || req.connection.remoteAddress) as string;
    const userAgent = req.headers['user-agent'] || 'Unknown';

    try {
      await handler(req, res);

      // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
      const responseTime = Date.now() - startTime;
      if (responseTime > 5000) {
        securityLogger.logSecurityEvent({
          type: 'suspicious_activity',
          severity: 'medium',
          ip,
          userAgent,
          details: {
            path: req.url,
            method: req.method,
            responseTime,
            reason: 'Slow response time',
          },
          timestamp: new Date(),
        });
      }
    } catch (error) {
      // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
      securityLogger.logSecurityEvent({
        type: 'suspicious_activity',
        severity: 'high',
        ip,
        userAgent,
        details: {
          path: req.url,
          method: req.method,
          error: error.message,
        },
        timestamp: new Date(),
      });

      throw error;
    }
  };
}
```

### Intrusion Detection

```typescript
// lib/security/intrusion-detection.ts
import { securityLogger } from './security-logger';

interface SuspiciousPattern {
  name: string;
  pattern: RegExp;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
}

export class IntrusionDetectionSystem {
  private suspiciousPatterns: SuspiciousPattern[] = [
    {
      name: 'SQL_INJECTION',
      pattern: /(union|select|insert|update|delete|drop|create|alter|exec|execute)\s+/i,
      severity: 'high',
      description: 'Potential SQL injection attempt',
    },
    {
      name: 'XSS_ATTEMPT',
      pattern: /<script[^>]*>.*?<\/script>/i,
      severity: 'high',
      description: 'Potential XSS attack',
    },
    {
      name: 'PATH_TRAVERSAL',
      pattern: /\.\.[\/\\]/,
      severity: 'medium',
      description: 'Potential path traversal attempt',
    },
    {
      name: 'COMMAND_INJECTION',
      pattern: /[;&|`$(){}\[\]]/,
      severity: 'high',
      description: 'Potential command injection',
    },
  ];

  private failedAttempts = new Map<string, number>();
  private blockedIPs = new Set<string>();

  analyzeRequest(req: NextApiRequest): void {
    const ip = (req.headers['x-forwarded-for'] || req.connection.remoteAddress) as string;
    const userAgent = req.headers['user-agent'] || 'Unknown';

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö IP
    if (this.blockedIPs.has(ip)) {
      throw new Error('IP address is blocked');
    }

    // –ê–Ω–∞–ª–∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∑–∞–ø—Ä–æ—Å–∞
    const allParams = {
      ...req.query,
      ...req.body,
      url: req.url,
      userAgent,
    };

    for (const [key, value] of Object.entries(allParams)) {
      if (typeof value === 'string') {
        this.checkForSuspiciousPatterns(value, ip, userAgent, key);
      }
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–∞—Å—Ç–æ—Ç—ã –∑–∞–ø—Ä–æ—Å–æ–≤
    this.checkRequestFrequency(ip, userAgent);
  }

  private checkForSuspiciousPatterns(
    input: string,
    ip: string,
    userAgent: string,
    parameter: string
  ): void {
    for (const pattern of this.suspiciousPatterns) {
      if (pattern.pattern.test(input)) {
        securityLogger.logSecurityEvent({
          type: 'suspicious_activity',
          severity: pattern.severity,
          ip,
          userAgent,
          details: {
            pattern: pattern.name,
            description: pattern.description,
            parameter,
            value: input,
          },
          timestamp: new Date(),
        });

        this.incrementFailedAttempts(ip);

        if (pattern.severity === 'critical' || pattern.severity === 'high') {
          throw new Error('Suspicious activity detected');
        }
      }
    }
  }

  private checkRequestFrequency(ip: string, userAgent: string): void {
    // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–∞—Å—Ç–æ—Ç—ã –∑–∞–ø—Ä–æ—Å–æ–≤
    // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ Redis –∏–ª–∏ –¥—Ä—É–≥–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
    const key = `${ip}:${Date.now()}`;
    // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —á–∞—Å—Ç–æ—Ç—ã
  }

  private incrementFailedAttempts(ip: string): void {
    const current = this.failedAttempts.get(ip) || 0;
    const newCount = current + 1;

    this.failedAttempts.set(ip, newCount);

    // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø–æ—Å–ª–µ 5 –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
    if (newCount >= 5) {
      this.blockedIPs.add(ip);

      securityLogger.logSecurityEvent({
        type: 'suspicious_activity',
        severity: 'critical',
        ip,
        userAgent: 'Unknown',
        details: {
          reason: 'IP blocked due to multiple suspicious attempts',
          attemptCount: newCount,
        },
        timestamp: new Date(),
      });

      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —á–µ—Ä–µ–∑ 1 —á–∞—Å
      setTimeout(
        () => {
          this.blockedIPs.delete(ip);
          this.failedAttempts.delete(ip);
        },
        60 * 60 * 1000
      );
    }
  }

  isBlocked(ip: string): boolean {
    return this.blockedIPs.has(ip);
  }

  unblockIP(ip: string): void {
    this.blockedIPs.delete(ip);
    this.failedAttempts.delete(ip);
  }
}

export const ids = new IntrusionDetectionSystem();

// Middleware –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –≤—Ç–æ—Ä–∂–µ–Ω–∏–π
export function withIntrusionDetection(
  handler: (req: NextApiRequest, res: NextApiResponse) => Promise<void>
) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    try {
      ids.analyzeRequest(req);
      return handler(req, res);
    } catch (error) {
      if (
        error.message === 'Suspicious activity detected' ||
        error.message === 'IP address is blocked'
      ) {
        return res.status(403).json({ error: 'Access denied' });
      }
      throw error;
    }
  };
}
```

## üîê –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö

### Encryption Service

```typescript
// lib/security/encryption.ts
import crypto from 'crypto';

export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyLength = 32;
  private readonly ivLength = 16;
  private readonly tagLength = 16;
  private readonly key: Buffer;

  constructor() {
    const keyString = process.env.ENCRYPTION_KEY;
    if (!keyString) {
      throw new Error('ENCRYPTION_KEY environment variable is required');
    }

    this.key = crypto.scryptSync(keyString, 'salt', this.keyLength);
  }

  encrypt(text: string): string {
    const iv = crypto.randomBytes(this.ivLength);
    const cipher = crypto.createCipher(this.algorithm, this.key, { iv });

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const tag = cipher.getAuthTag();

    // –û–±—ä–µ–¥–∏–Ω—è–µ–º IV, tag –∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    return iv.toString('hex') + tag.toString('hex') + encrypted;
  }

  decrypt(encryptedData: string): string {
    const iv = Buffer.from(encryptedData.slice(0, this.ivLength * 2), 'hex');
    const tag = Buffer.from(
      encryptedData.slice(this.ivLength * 2, (this.ivLength + this.tagLength) * 2),
      'hex'
    );
    const encrypted = encryptedData.slice((this.ivLength + this.tagLength) * 2);

    const decipher = crypto.createDecipher(this.algorithm, this.key, { iv });
    decipher.setAuthTag(tag);

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  hash(data: string): string {
    return crypto.createHash('sha256').update(data).digest('hex');
  }

  hashPassword(password: string): string {
    const salt = crypto.randomBytes(16).toString('hex');
    const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');
    return `${salt}:${hash}`;
  }

  verifyPassword(password: string, hashedPassword: string): boolean {
    const [salt, hash] = hashedPassword.split(':');
    const verifyHash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');
    return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(verifyHash));
  }

  generateSecureToken(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex');
  }
}

export const encryption = new EncryptionService();
```

## üåê HTTPS –∏ TLS

### SSL/TLS Configuration

```javascript
// next.config.js - HTTPS –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
const nextConfig = {
  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ HTTPS –≤ production
  async redirects() {
    if (process.env.NODE_ENV === 'production') {
      return [
        {
          source: '/(.*)',
          has: [
            {
              type: 'header',
              key: 'x-forwarded-proto',
              value: 'http',
            },
          ],
          destination: 'https://ai-agency.com/:path*',
          permanent: true,
        },
      ];
    }
    return [];
  },

  // Security headers
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=31536000; includeSubDomains; preload',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block',
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin',
          },
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=()',
          },
        ],
      },
    ];
  },
};

module.exports = nextConfig;
```

## üîí –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è

### –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–∞–º–∏

```bash
# .env.example - –ü—Ä–∏–º–µ—Ä –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è

# –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
NODE_ENV=production
NEXT_PUBLIC_APP_URL=https://ai-agency.com

# –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å
JWT_SECRET=your-super-secret-jwt-key-here
JWT_ISSUER=ai-agency
JWT_AUDIENCE=ai-agency-users
ENCRYPTION_KEY=your-encryption-key-here
CSRF_SECRET=your-csrf-secret-here

# –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
DATABASE_URL=postgresql://user:password@localhost:5432/ai_agency
REDIS_URL=redis://localhost:6379

# –í–Ω–µ—à–Ω–∏–µ —Å–µ—Ä–≤–∏—Å—ã
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –∞–ª–µ—Ä—Ç—ã
SLACK_SECURITY_WEBHOOK=https://hooks.slack.com/services/...
ADMIN_EMAIL=admin@ai-agency.com

# API –∫–ª—é—á–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è production)
GOOGLE_ANALYTICS_ID=GA_MEASUREMENT_ID
SENTRY_DSN=https://your-sentry-dsn
```

### –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è

```typescript
// lib/config/env-validation.ts
import { z } from 'zod';

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'test', 'production']),
  NEXT_PUBLIC_APP_URL: z.string().url(),

  // –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å
  JWT_SECRET: z.string().min(32),
  JWT_ISSUER: z.string(),
  JWT_AUDIENCE: z.string(),
  ENCRYPTION_KEY: z.string().min(32),
  CSRF_SECRET: z.string().min(32),

  // –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
  DATABASE_URL: z.string().url(),
  REDIS_URL: z.string().url(),

  // Email
  SMTP_HOST: z.string(),
  SMTP_PORT: z.string().transform(Number),
  SMTP_USER: z.string().email(),
  SMTP_PASS: z.string(),

  // –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
  SLACK_SECURITY_WEBHOOK: z.string().url().optional(),
  ADMIN_EMAIL: z.string().email(),

  // –ê–Ω–∞–ª–∏—Ç–∏–∫–∞
  GOOGLE_ANALYTICS_ID: z.string().optional(),
  SENTRY_DSN: z.string().url().optional(),
});

export function validateEnv() {
  try {
    const env = envSchema.parse(process.env);
    return env;
  } catch (error) {
    console.error('‚ùå Invalid environment variables:');
    console.error(error.errors);
    process.exit(1);
  }
}

// –í–∞–ª–∏–¥–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
if (process.env.NODE_ENV === 'production') {
  validateEnv();
}
```

## üîç –ê—É–¥–∏—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

### –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞—É–¥–∏—Ç

```json
// package.json - —Å–∫—Ä–∏–ø—Ç—ã –¥–ª—è –∞—É–¥–∏—Ç–∞
{
  "scripts": {
    "security:audit": "npm audit --audit-level=moderate",
    "security:fix": "npm audit fix",
    "security:check": "npm run security:audit && npm run security:snyk",
    "security:snyk": "snyk test",
    "security:lighthouse": "lighthouse-ci",
    "security:headers": "node scripts/check-security-headers.js"
  }
}
```

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

```javascript
// scripts/check-security-headers.js
const https = require('https');
const { URL } = require('url');

const requiredHeaders = {
  'strict-transport-security': 'HSTS header missing',
  'x-content-type-options': 'X-Content-Type-Options header missing',
  'x-frame-options': 'X-Frame-Options header missing',
  'x-xss-protection': 'X-XSS-Protection header missing',
  'content-security-policy': 'CSP header missing',
  'referrer-policy': 'Referrer-Policy header missing',
};

function checkSecurityHeaders(url) {
  return new Promise((resolve, reject) => {
    const parsedUrl = new URL(url);

    const options = {
      hostname: parsedUrl.hostname,
      port: parsedUrl.port || 443,
      path: parsedUrl.pathname,
      method: 'HEAD',
    };

    const req = https.request(options, res => {
      const headers = res.headers;
      const results = [];

      for (const [header, message] of Object.entries(requiredHeaders)) {
        if (!headers[header]) {
          results.push({ header, status: 'MISSING', message });
        } else {
          results.push({ header, status: 'PRESENT', value: headers[header] });
        }
      }

      resolve(results);
    });

    req.on('error', reject);
    req.end();
  });
}

async function main() {
  const url = process.env.NEXT_PUBLIC_APP_URL || 'https://localhost:3000';

  try {
    console.log(`Checking security headers for: ${url}`);
    const results = await checkSecurityHeaders(url);

    let hasIssues = false;

    results.forEach(result => {
      if (result.status === 'MISSING') {
        console.error(`‚ùå ${result.message}`);
        hasIssues = true;
      } else {
        console.log(`‚úÖ ${result.header}: ${result.value}`);
      }
    });

    if (hasIssues) {
      process.exit(1);
    } else {
      console.log('\n‚úÖ All security headers are present!');
    }
  } catch (error) {
    console.error('Error checking headers:', error.message);
    process.exit(1);
  }
}

main();
```

## üìã –ß–µ–∫-–ª–∏—Å—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

### –†–∞–∑—Ä–∞–±–æ—Ç–∫–∞

- [ ] –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- [ ] –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –ë–î
- [ ] –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ HTML –≤—ã–≤–æ–¥–∞
- [ ] –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –¥–ª—è –≤—Å–µ—Ö –∑–∞—â–∏—â–µ–Ω–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
- [ ] –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ HTTPS –¥–ª—è –≤—Å–µ—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
- [ ] –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–æ–≤
- [ ] –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
- [ ] –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π

### –ò–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞

- [ ] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ WAF (Web Application Firewall)
- [ ] –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
- [ ] –†–µ–∑–µ—Ä–≤–Ω–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
- [ ] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ SSL/TLS —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤
- [ ] –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–º –ø–∞–Ω–µ–ª—è–º
- [ ] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∏—Å—Ç–µ–º—ã –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –≤—Ç–æ—Ä–∂–µ–Ω–∏–π
- [ ] –†–µ–≥—É–ª—è—Ä–Ω—ã–µ —Ç–µ—Å—Ç—ã –Ω–∞ –ø—Ä–æ–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–µ

### –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º

- [ ] GDPR compliance –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- [ ] OWASP Top 10 –∑–∞—â–∏—Ç–∞
- [ ] SOC 2 Type II —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ
- [ ] ISO 27001 —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã

## üìû –ö–æ–Ω—Ç–∞–∫—Ç—ã –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

**Security Team**

- Email: security@ai-agency.com
- PGP Key: [–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á]
- Response Time: 24 —á–∞—Å–∞

**Bug Bounty Program**

- Platform: HackerOne
- Scope: https://ai-agency.com/*
- Rewards: $100 - $5000

**Emergency Contact**

- Phone: +1-XXX-XXX-XXXX
- Available: 24/7
- For critical security incidents only
